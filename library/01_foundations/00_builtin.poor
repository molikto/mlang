define id(#A: type, a: A): A = a

define refl(#A: type, #a: A): a ≡ a = i → a

// ideal syntax: x.refl
define x_refl(#A: type, a: A): a ≡ a = i → a

define x_refl_type(#A: type, a: A) = a ≡ a

// p.reverse
define path_reverse(#A: type, #x #y: A, p: x ≡ y): y ≡ x =
  i → p(~i)



// FIXME(META) why replace the body with refl doesn't works?
define path_reverse_unit(#A: type, x: A): (─ → x) ≡[─ → x ≡ x] path_reverse(x_refl(x)) =
  ─ → (─ → x)


// idea syntax: p.reverse statically determined!!
define dependent_path_reverse(#A1 #A2: type, #A: A1 ≡ A2, #x: A1, #y: A2, p: x ≡[A] y): y ≡[^path_reverse(A)] x =
  i → p(~i)

define path_compose(#A: type, #x #y #z: A, xy: x ≡ y, yz: y ≡ z): x ≡ z =
  i → hcomp(xy(i) |~i: x_refl(x) |i: yz)


// TODO what syntax and name should this be? a.transp(p), p.transp(a), a^p, a|P, transp(a, p)???
define transport(#A #B: type, P: A ≡ B, a: A): B = transp(P, 0, a)

define transport_refl(#A: type, a: A): transport(─ → A, a) ≡ a =
  i → transp(─ → A, i, a)


define subst(#A: type, B: A ⇒ type, #x #y: A, p: x ≡ y, bx: B(x)): B(y) =
  transport(i → B(p(i)), bx)

define J_rule(#A: type, #x #y: A, P: (z: A, : x ≡ z) ⇒ type, d: P(x, refl), p: x ≡ y): P(y, p) =
  transport(i → P(p(i), j → p(i ∧ j)), d)

// #f #g: (x: #A) ⇒ #B(x),
define fun_ext(#A: type, #B: A ⇒ type, #f #g: (x: A) ⇒ B(x), p: (x: A) ⇒ f(x) ≡ g(x)): f ≡ g =
  i → x → p(x, i)

// TODO what's a proper name for this?
// define apd(#A: type, #B: A ⇒ type, f: (x: A) ⇒ B(x), x y: A, p: x ≡ y): coe(0, 1, i → B(p(i)), f(x)) ≡ f(y) =
//  i → coe(i, 1, j → B(p(j)), f(p(i)))


// cong(f, p) or p.map(f) or f.path_app(p) even f(p)?
define path_map(#A: type, #B: A ⇒ type, f: (x: A) ⇒ B(x), #x #y: A, p: x ≡ y): f(x) ≡[i → B(p(i))] f(y) =
  i → f(p(i))


// TODO define cong₂ in Cubical Agda


define is_prop(A: type): type = (a b: A) ⇒ a ≡ b

define is_set(A: type): type = (x y: A) ⇒ is_prop(x ≡ y)

define is_groupoid(A: type): type = (a b: A) ⇒ is_set(a ≡ b)

define is_groupoid2(A: type): type = (a b: A) ⇒ is_groupoid(a ≡ b)


define connection_both(#A: type, #a: A, p: a ≡ a): p ≡[i → p(i) ≡ p(i)] p =
  i → j → hcomp(a |~i: k → p(j∨(~k)) |i: k → p(j∧k) |~j: k → p(i∨(~k)) |j: k → p(i∧k))

define is_contr(A: type): type = record {
  field center: A
  field to_center: (a: A) ⇒ center ≡ a
}

// TODO this is a perfect example, a: fiber_at(a, b) should have reloaded application on both term and dimension
define fiber_at(#A #B: type, f: A ⇒ B, b: B): type = record {
  field from: A
  field path: f(from) ≡ b
}

define is_equiv(#T #A: type, f: T ⇒ A): type =
  (a: A) ⇒ is_contr(fiber_at(f, a))

define equiv(T A: type): type = record {
  field f: T ⇒ A
  field component: is_equiv(f)
}

define equiv_of(A: type): type = record {
  field T: type
  field eq: equiv(T, A)
}

// adapted from cubical agda
define path_to_equiv(#A #B: type, E: A ≡ B): equiv(A, B) = run {
  define Ei: B ≡ A = i → E(~i)
  define f(x: A): B = transp(E, 0, x)
  define g(y: B): A = transp(i → E(~i), 0, y)
  define u(x: A, i: I): E(i) = transp(j → E(i∧j), ~i, x)
  define v(y: B, i: I): E(i) = transp(j → Ei((~i)∧j), i, y)
  define fiber_path(y: B, fib0 fib1: fiber_at(f, y)): fib0 ≡ fib1 = k → run {
    define t(fib: fiber_at(f, y), j: I) = fill(Ei, fib.path(~j) |~j: i → v(y, ~i) |j: i → u(fib.from, ~i))
    define t0 = t(fib0)
    define t1 = t(fib1)
    define tt = hfill(g(y) |~k: j → t0(j, 1) |k: j → t1(j, 1))
    define w = tt(1)
    define dt(j: I) = comp(E, tt(j) |~j: v(y) |~k: i → t0(j, ~i) | j: u(w) | k: i → t1(j, ~i))
    fiber_at(f, y).make(w, j → dt(~j))
  }
  define yy(y: B): y ≡ f(g(y)) = j → comp(E, g(y) |~j: v(y) |j: u(g(y)))

  define equ(y: B): is_contr(fiber_at(f, y)) = run {
    define center: fiber_at(f, y) = make(g(y), k → yy(y, ~k))
    make(center, fiber_path(y, center))
  }
  make(f, equ)
}







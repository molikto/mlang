


define join_S1 = join(S1, S1)

define join_S1_pointed = pointed.make(@join_S1, join_S1.inl(S1.base))

define join_S1_facek01(i j k: I): join_S1 =
  hfill(join_S1.push(S1.base, S1.base, ~k)
  |~j: l → join_S1.push(S1.base, S1.base, (~l)∧(~k))
  | j: l → join_S1.push(S1.base, S1.base, (~l)∧(~k))
  |~k: l → join_S1.push(S1.loop(j), S1.base, (~l))
  | k: l → join_S1.inl(S1.base)
  )(i)

// TODO support border k or, or expressions in partial elements
define join_S1_border_contraction(i j k m: I): join_S1 =
  hfill(join_S1.push(S1.loop(j), S1.loop(k), i)
  |~i: l → join_S1_facek01(1, j, l)
  | i: l → join_S1.push(S1.base, S1.loop(k), ~l)
  |~j: l → join_S1.push(S1.base, S1.loop(k), (i)∧(~l))
  | j: l → join_S1.push(S1.base, S1.loop(k), (i)∧(~l))
  |~k: l → join_S1_facek01(~i, j, l)
  | k: l → join_S1_facek01(~i, j, l)
  )(m)



define S3_to_join_S1
: S3 ⇒ join_S1 =
┌ base → join_S1.inl(S1.base)
└ surf(j, k, i) → join_S1_border_contraction(i, j, k, 1)


define inductively post_total_hopf: type = sum {
  case base(: S1)
  case loop(x: S1, i j: I
  |i: base(x)
  |~i: base(x)
  |~j: base(x)
  |j: base(rot_loop(x, ~i))
  )
}
define tee12:
 (x: S2, y: S2_hopf(x)) ⇒ post_total_hopf =
┌ base → y → post_total_hopf.base(y)
└ surf(i, j) → y →
    hcomp(post_total_hopf.loop(unglue(y), i, j)
    |~i: k → post_total_hopf.base(y)
    |i: k → post_total_hopf.base(y)
    |~j: k → post_total_hopf.base(y)
    |j: k → post_total_hopf.base(rot_loop_inv(y, ~i, k))
    )

define tee34: post_total_hopf ⇒ join_S1 =
┌ base(x) → join_S1.inl(x)
└ loop(x, i, j) → hcomp(join_S1.push(x, x, j)
                  |~i: k → join_S1.push(x, x, j∧(~k))
                  |i: k → join_S1.push(x, x, j∧(~k))
                  |~j: k → join_S1.inl(x)
                  |j: k → join_S1.push(rot_loop(x, ~i), x, ~k)
                  )

define tee(x: S2, y: S2_hopf(x)): join_S1 = tee34(tee12(x, y))

/**

**/
